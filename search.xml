<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang web项目结构剖析</title>
    <url>/2021/06/09/Golang-web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="2021-6-10-晴"><a href="#2021-6-10-晴" class="headerlink" title="2021.6.10 晴"></a>2021.6.10 晴</h2><p>最近在做项目的时候，发现自己原来划分的结构非常粗糙，代码分层非常不清晰，因此花时间重构了一下，这里将重构前后的结构和代码进行对比。</p>
<span id="more"></span>

<h2 id="原来的结构"><a href="#原来的结构" class="headerlink" title="原来的结构"></a>原来的结构</h2><p><img src="/2021/06/09/Golang-web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/1.png" alt="原来的结构"></p>
<h3 id="结构问题"><a href="#结构问题" class="headerlink" title="结构问题"></a>结构问题</h3><p>先来说说结构上的问题。</p>
<p>如图：</p>
<p>第一个包 common  放的是第三方包和全局变量。</p>
<p>例如一些const、email和log。</p>
<p>第二个包config放的是对配置文件的读取和初始化。</p>
<p>db是数据库的连接，初始化数据库引擎。</p>
<p>而这里很蠢的是直接把数据库连接的信息写进了代码里，而正确的做法应该是把必要的信息写进配置文件中。</p>
<p>docs包是接口文档存放的地方。</p>
<p>log包里维护了一个log文件，存放着程序运行过程中产生的问题。</p>
<p>upload是存放着用户上传的文件(例如头像之类的)，这里设计及其愚蠢的地方是我把用户的上传的文件放在了项目里面，这会增加项目的体积，还会带来额外的网络开销。</p>
<p>而controller、model、service就是我们的老熟人了。</p>
<p>controller是路由的处理逻辑，而model层是与数据库打交道，service是在这两层中间的联系人。</p>
<p>这样的分层结构非常愚蠢且粗糙，在发现这一点后，我毫不犹豫的决定抛弃它，进行重构。</p>
<h3 id="代码问题"><a href="#代码问题" class="headerlink" title="代码问题"></a>代码问题</h3><p>在这样糟糕的结构下，我写代码的时候，对于代码应该写在哪一层还是浑浑噩噩，因此这个项目写的非常的不优雅。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UploadImg</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   file,err := c.FormFile(<span class="string">&quot;Img&quot;</span>)</span><br><span class="line">   email := c.PostForm(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">   url := service.CheckImgUrl(email)</span><br><span class="line">   <span class="keyword">if</span> url != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      _ = os.Remove(url)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      WriteJsonCode(c,Code,ImgGetWErr)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   size := file.Size</span><br><span class="line">   <span class="keyword">if</span> size &gt; <span class="keyword">int64</span>(ImgLimit) &#123;</span><br><span class="line">      WriteJsonCode(c,Code,ImgSizeLimited)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> file == <span class="literal">nil</span> &#123;</span><br><span class="line">      WriteJsonCode(c,Code, ImgNil)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fileExt := filepath.Ext(file.Filename)</span><br><span class="line">   <span class="keyword">if</span> fileExt != <span class="string">&quot;.jpg&quot;</span> &amp;&amp; fileExt != <span class="string">&quot;.png&quot;</span> &amp;&amp; fileExt != <span class="string">&quot;.jpeg&quot;</span> &#123;</span><br><span class="line">      WriteJsonCode(c,Code,ImgFormatErr)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   file.Filename = service.GetImgName() + fileExt</span><br><span class="line">   err = c.SaveUploadedFile(file,defImgUrl + file.Filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      WriteJsonCode(c,Code,ImgSaveErr)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ok := service.SaveImgName(email, defImgUrl + file.Filename); !ok &#123;</span><br><span class="line">      WriteJsonCode(c,Code,ImgSaveErr)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   WriteJsonCode(c,Code,ImgSaveSuccess)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个处理用户上传头像的路由。</p>
<p>下面是这个路由调用到的service层的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckImgUrl</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> model.CheckImgUrl(email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetImgName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Now().Format(defDateAndTime) + krandom.CreateRandomNumber(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveImgName</span><span class="params">(email,url <span class="keyword">string</span>)</span> <span class="title">bool</span></span>  &#123;</span><br><span class="line">   <span class="keyword">return</span> model.SaveImgUrl(email,url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我的controller层里的函数写的非常长，对文件的判断都放在了路由里，而在service里，只有短短的一行代码，去调用model层的函数。</p>
<p>这种写法无疑是非常不合理的。</p>
<p>controller里应当只从ctx里拿取数据，然后传给service，以及返回结果。</p>
<p>如果不得不进行逻辑的处理，应该只保留最小限度的代码，已经错误处理。</p>
<p>这个问题在重构之后得到了解决。</p>
<h2 id="重构之后"><a href="#重构之后" class="headerlink" title="重构之后"></a>重构之后</h2><p><img src="/2021/06/09/Golang-web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/2.png" alt="重构之后的结构"></p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>这是重构之后的项目结构。</p>
<p>可以看到，划分了更多的包出来。</p>
<ul>
<li>configs：存放配置文件。</li>
<li>docs：接口文档集合。</li>
<li>global：全局变量。例如数据库引擎，log全局变量，发送邮件的client等。</li>
<li>internal：内部模块。<ul>
<li>dao：数据访问层（Database Access Object），所有与数据相关的操作都会在 dao 层进行，这里替代了原项目中的model层的作用。</li>
<li>middleware： HTTP 中间件。</li>
<li>model：模型层，用于存放 model 对象。将结构体放在这里。</li>
<li>request：放请求入参的结构体，方便入参时的绑定。</li>
<li>response：返回数据的类型。例如一个结构体中有一个字段为用户密码，而在返回时是不能够返回这个字段的数据的，因此要定义新的结构体去返回该返回的信息。</li>
<li>routers：路由相关逻辑处理。<ul>
<li>qpi<ul>
<li>base：这里是路由的位置，因为项目里这个路由组为：api/base/*，因此这里是这样命名。</li>
<li>router.go 路由文件</li>
</ul>
</li>
</ul>
</li>
<li>service：项目核心业务逻辑。</li>
</ul>
</li>
<li>log： log包里维护了一个log文件，存放着程序运行过程中产生的问题。</li>
<li>pkg：项目相关的模块包。<ul>
<li>app：存放着一一些公共组件。比如jwt的解析，响应信息的处理。</li>
<li>convert： 这里定义了一些可能会用到的类型转换的组件</li>
<li>email： email配置的读取已经emailClient的初始化</li>
<li>errcode： 定义了一些常用错误码，当需要返回错误信息时，直接调用此包的方法即可。</li>
<li>logger： log的初始化</li>
<li>setting： 配置文件的读取，程序的初始化。</li>
</ul>
</li>
</ul>
<p>原来的用户上传的文件，放在了另外的文件夹，虽然不能避免网络的开销，但是避免了项目的体积变大。(阿里云的oss太坑了)</p>
<p>将项目结构细化之后，代码应该放在哪里就清晰了很多。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>再来重新看关于上传头像的路由以及逻辑处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">UpLoadImg</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   file,Err := c.FormFile(<span class="string">&quot;Img&quot;</span>)</span><br><span class="line">   response := app.NewResponse(c)</span><br><span class="line">   <span class="keyword">var</span> email <span class="keyword">string</span></span><br><span class="line">   i,ok := c.Get(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      response.ToErrorResponse(errcode.InvalidParams)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   email = i.(<span class="keyword">string</span>)</span><br><span class="line">   <span class="keyword">if</span> Err != <span class="literal">nil</span> &#123;</span><br><span class="line">      response.ToErrorResponse(errcode.InvalidParams)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   err := services.UpLoadImg(c,file,email)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      response.ToErrorResponse(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   response.ToResponse(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了获取参数以及错误处理和信息响应，再无多余的代码。</p>
<p>而service：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpLoadImg</span><span class="params">(c *gin.Context,file *multipart.FileHeader, email <span class="keyword">string</span>)</span> *<span class="title">errcode</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">   <span class="comment">//邮箱不存在就返回</span></span><br><span class="line">   <span class="keyword">if</span> ok := CheckEmail(email); ok &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode.NotFound</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查文件是否可用</span></span><br><span class="line">   err := fileReady(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//检查之前是否上传过头像</span></span><br><span class="line">   url,err := dao.CheckImg(email)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   do := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="comment">//url不为空 说明上传过</span></span><br><span class="line">   <span class="keyword">if</span> url != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="comment">//删除原来的</span></span><br><span class="line">      <span class="comment">//这里开启一个协程去做 是因为当把新的头像更新后才能去删除 删除使用channel通知</span></span><br><span class="line">      <span class="comment">//就算没有删除成功 也更新成功了 数据库里存的是用户更新后的数据</span></span><br><span class="line">      <span class="comment">//没有删除成功 会在日志文件里写入警告</span></span><br><span class="line">      <span class="keyword">go</span> deleteAvatar(url,do)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//改变文件名</span></span><br><span class="line">   file.Filename = getImgName() + filepath.Ext(file.Filename)</span><br><span class="line">   <span class="comment">//保存</span></span><br><span class="line">   e := c.SaveUploadedFile(file, defAvatarUrl+ file.Filename)</span><br><span class="line">   <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode.OsErr</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//数据库里保存</span></span><br><span class="line">   err = dao.SaveImgUrl(email, defAvatarUrl+ file.Filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//这里去通知删除旧文件</span></span><br><span class="line">   <span class="comment">//直接关闭do即可 协程中会读取0值</span></span><br><span class="line">   <span class="built_in">close</span>(do)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除旧文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteAvatar</span><span class="params">(url <span class="keyword">string</span>,do <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;- do:</span><br><span class="line">      err := os.Remove(url)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         global.Logger.Errorf(<span class="string">&quot;旧文件未及时删除!文件地址为：&quot;</span>,url)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileReady</span><span class="params">(file *multipart.FileHeader)</span> *<span class="title">errcode</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">   <span class="comment">//判断文件是否超出限制大小</span></span><br><span class="line">   size := file.Size</span><br><span class="line">   <span class="keyword">if</span> size &gt; <span class="keyword">int64</span>(ImgLimit) &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode.FileTooLarge</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//文件为空</span></span><br><span class="line">   <span class="keyword">if</span> file == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode.FileIsNil</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断文件类型</span></span><br><span class="line">   fileExt := filepath.Ext(file.Filename)</span><br><span class="line">   <span class="keyword">if</span> fileExt != <span class="string">&quot;.jpg&quot;</span> &amp;&amp; fileExt != <span class="string">&quot;.png&quot;</span> &amp;&amp; fileExt != <span class="string">&quot;.jpeg&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode.FileFormatErr</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将逻辑的处理全部放进service，并且对于可重用的部分做了抽离。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在对项目进行重构之后，项目的粒度变细，结构更清晰且易于编写代码。</p>
<p>虽然重构很花时间，而且很费精力，但我觉得很值得。</p>
<p>制定的规范、划分的结构，会帮助你的后期代码更好写。</p>
<p>而优化结构也是一个程序员应该一直考虑的事情。</p>
<p>该项目我已经开源：<a href="https://github.com/sta-golang/soft">sta-golang/soft (github.com)</a></p>
<p>希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>golang</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>web</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言context超时控制的用法</title>
    <url>/2021/05/30/go%E8%AF%AD%E8%A8%80context%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>这篇博客来说一说go语言中的context的用法。</p>
<p>这玩意曾经折磨了我一早上。</p>
<p>(从各方面来讲都很离谱)</p>
<span id="more"></span>

<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>首先来讲讲什么是context。</p>
<p>暂且不提其在go中的定义，我们先来在csdn上搜搜看。</p>
<p>可以看到的是，不止有go有这玩意。(妙啊)</p>
<p>而context被很多人译为上下文。</p>
<p>怎么样，听起来是不是很耳熟？</p>
<p>“当发生进程的切换时，操作系统会保存上下文，即进程运行的必要信息，以待切换回来时恢复现场。”</p>
<p>确实很熟悉。</p>
<p>那么现在就明了了，这玩意就是一些参数，就是现场。</p>
<p>一个函数想要执行，那它会需要一些必要的参数。</p>
<p>进程想要恢复，它会拿保存下来的参数去恢复现场。</p>
<p>你淘宝里想要清空购物车，它需要拿到你之前添加进购物车里的商品，什么东西，多少件，一件多少钱，这些都是参数。</p>
<p>这就是context，它的概念不属于某种语言，而是归于编程这一个大类。</p>
<h2 id="go语言中的context"><a href="#go语言中的context" class="headerlink" title="go语言中的context"></a>go语言中的context</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>那么context在go中有什么样的表现呢？</p>
<p>“Package context defines the Context type, which carries deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.”</p>
<p>这是go标准库里对context的定义。</p>
<p>大意：context包定义了context结构，这个结构会在API和进程之间传递截至日期、取消信号和请求范围的值。</p>
<p>人话：这就是个上下文，保存一堆参数，在函数或一堆goroutine之间传来传去进行控制。</p>
<p>但是它也有其特点。</p>
<p>普通的上下文只是保存了一些参数，而go里的context会为其最大的特性——goroutine而服务。</p>
<p>这段说的特别好，在此引用：</p>
<p>“在Go 里，我们不能直接杀死协程，协程的关闭一般会用channel+select方式来控制。但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的deadline等，而且可以同时被关闭。再用channel+select就会比较麻烦，这时就可以通过context来实现。</p>
<p>一句话：context用来解决 goroutine 之间退出通知、元数据传递的功能。”</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><a href="https://blog.csdn.net/u013474436/article/details/108410246?ops_request_misc=%7B%22request_id%22:%22162246005416780265474250%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162246005416780265474250&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108410246.first_rank_v2_pc_rank_v29&utm_term=go+context&spm=1018.2226.3001.4187">(11条消息) Go context详解_稻草人技术博客-CSDN博客</a></p>
<p>看写好的博客就好了</p>
<p>(本懒狗只会白嫖)</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在看完数据结构、源码详解后，我大呼过瘾。</p>
<p>但是一琢磨，用这玩意儿在项目里去定时，该怎么用呢？</p>
<p>完蛋，上当了，看是看懂了，用是用废了。</p>
<p>比如说，当用withTimeOut后，cancel()函数必须显示的调用吗？</p>
<p>在接收ctx的函数里，一定要用select去接收吗？</p>
<p>一个ctx可以一直传吗？</p>
<p>满脑子问号。</p>
<p>于是自己写了些测试的demo，去试试这玩意儿是怎么个用法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个子节点的context,3秒后自动超时</span></span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;监控1&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;监控2&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch1(ctx, <span class="string">&quot;监控3&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;现在开始等待8秒,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">	time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine end, time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独的监控协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;收到信号，监控退出,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;goroutine监控中,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;goroutine监控中,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">现在开始等待6秒,time= 22:10:41</span><br><span class="line">监控2 goroutine监控中,time= 22:10:41</span><br><span class="line">监控1 goroutine监控中,time= 22:10:41</span><br><span class="line">监控3 goroutine监控中,time= 22:10:41</span><br><span class="line">监控3 goroutine监控中,time= 22:10:42</span><br><span class="line">监控2 goroutine监控中,time= 22:10:42</span><br><span class="line">监控1 goroutine监控中,time= 22:10:42</span><br><span class="line">监控2 goroutine监控中,time= 22:10:43</span><br><span class="line">监控3 goroutine监控中,time= 22:10:43</span><br><span class="line">监控1 goroutine监控中,time= 22:10:43</span><br><span class="line">监控3 goroutine监控中,time= 22:10:44</span><br><span class="line">监控2 收到信号，监控退出,time= 22:10:44</span><br><span class="line">监控1 收到信号，监控退出,time= 22:10:44</span><br><span class="line">监控3 goroutine监控中,time= 22:10:45</span><br><span class="line">监控3 goroutine监控中,time= 22:10:46</span><br><span class="line">main goroutine end, time= 22:10:47</span><br></pre></td></tr></table></figure>

<p>通过这个demo，可以直观的看到其的一些特性。</p>
<p>1.即使不接收WithTimeout的第二个返回值，用占位符代替，到时间也是会自动执行cancel()的。</p>
<p>2.在接收ctx的函数里，一定要用select去接收。如果不接收，函数就会自顾自的跑下去，谁来了也不顶用。</p>
<p>两个疑问解决了，那么第三个疑问呢？</p>
<p>不要急，改一改demo就能得到结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;go-Kirby-utils/ktime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个子节点的context,3秒后自动超时</span></span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;监控1&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch1(ctx, <span class="string">&quot;监控2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;现在开始等待6秒,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">	time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine end, time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独的监控协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> watch2(ctx,<span class="string">&quot;监控3&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;收到信号，监控退出,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;goroutine监控中,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;goroutine监控中,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch2</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;收到信号，监控退出,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;goroutine监控中,time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">现在开始等待6秒,time= 22:15:03</span><br><span class="line">监控2 goroutine监控中,time= 22:15:03</span><br><span class="line">监控3 goroutine监控中,time= 22:15:03</span><br><span class="line">监控1 goroutine监控中,time= 22:15:03</span><br><span class="line">监控2 goroutine监控中,time= 22:15:04</span><br><span class="line">监控3 goroutine监控中,time= 22:15:04</span><br><span class="line">监控1 goroutine监控中,time= 22:15:04</span><br><span class="line">监控3 goroutine监控中,time= 22:15:05</span><br><span class="line">监控2 goroutine监控中,time= 22:15:05</span><br><span class="line">监控1 goroutine监控中,time= 22:15:05</span><br><span class="line">监控3 收到信号，监控退出,time= 22:15:06</span><br><span class="line">监控2 goroutine监控中,time= 22:15:06</span><br><span class="line">监控1 收到信号，监控退出,time= 22:15:06</span><br><span class="line">监控2 goroutine监控中,time= 22:15:07</span><br><span class="line">监控2 goroutine监控中,time= 22:15:08</span><br><span class="line">main goroutine end, time= 22:15:09</span><br></pre></td></tr></table></figure>

<p>可以看出，传进watch的ctx又被传进了watch2，而在结果中，watch2确确实实是在发挥作用的。</p>
<p>因此，我们的三个问题已经有答案了。</p>
<p>Q:当用withTimeOut后，cancel()函数必须显示的调用吗？</p>
<p>A:即使不接收WithTimeout的第二个返回值，用占位符代替，到时间也是会自动执行cancel()的。</p>
<p>Q：在接收ctx的函数里，一定要用select去接收吗？</p>
<p>A:在接收ctx的函数里，一定要用select去接收。如果不接收，函数就会自顾自的跑下去，谁来了也不顶用。</p>
<p>Q：一个ctx可以一直传吗？</p>
<p>A:可以用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此，我们可以总结一下context实现超时控制。</p>
<p>1.首先，应该调用withTimeOut方法获取ctx，cancel函数可以选择用占位符接收；</p>
<p>2.在接收ctx的函数中，想要不浪费资源，则要实现select去接收ctx.Done()；</p>
<p>3.使用select的话，就要善用goroutine和channel，普通的函数接收返回值是不行的。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line">	test(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//do something 这里使用sleep来模拟</span></span><br><span class="line">	<span class="comment">//假定需要5秒去执行</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;test end!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法就毫无意义。</p>
<p>只有当select之前的代码执行结束后，select才会执行。</p>
<p>如果把select放在前面，则又会阻塞后续代码的执行。</p>
<p>因此，应当是使用goroutine把要执行的代码放进一个协程去做，而这个函数只要等待就好了。</p>
<p>就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line">	test(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//do something 这里使用go doSomething来模拟 假定需要5秒执行时间</span></span><br><span class="line">	<span class="keyword">go</span> doSomething()</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;test end!&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println( <span class="string">&quot;time=&quot;</span>, ktime.GetNowTimeStr())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">time= <span class="number">22</span>:<span class="number">44</span>:<span class="number">18</span></span><br><span class="line">time= <span class="number">22</span>:<span class="number">44</span>:<span class="number">19</span></span><br><span class="line">time= <span class="number">22</span>:<span class="number">44</span>:<span class="number">20</span></span><br><span class="line">time= <span class="number">22</span>:<span class="number">44</span>:<span class="number">21</span></span><br><span class="line">test end!</span><br></pre></td></tr></table></figure>

<p>模拟doSomething需要5秒执行结束，而程序三秒后就退出了，证明有效。</p>
<p>因此，context应该搭配goroutine使用。</p>
<p>至于函数的返回值，给函数传一个管道，然后让函数执行结束之后往管道里塞数据就可以啦。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>关于context控制超时的分享就到这里啦~</p>
<p>希望对你有所帮助。</p>
<p>如果发现我的文章里有错的地方，请不吝赐教，通过QQ:1582086492与我联系！</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang项目——纳新报名网站</title>
    <url>/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>离准备面试的时间只剩下半年左右的时间了，而身为菜鸟的我还没有做拿得出手的项目。</p>
<p>于是开始考虑该做点什么东西才能忽悠(bushi)面试官。</p>
<span id="more"></span>

<p>想来想去，给实验室做个官网吧，当作自己的第一个项目。</p>
<p>可是之前没有写过大型的网站，脑壳疼。</p>
<p>那就先写个纳新报名的网站吧！实验室每年都纳新，实用性有了。后面把这玩意集成到官网里去，相当于官网完成一个部分了(摸鱼)。</p>
<p>说干就干！</p>
<p>然后……三天以后……完成了……</p>
<p>嗯……简单的过分。</p>
<p>正好又在周末摸鱼把个人博客搭起来了，那就在此记录一番。</p>
<h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><p>web框架：gin</p>
<p>数据库：mysql</p>
<p>数据库交互：gorm</p>
<p>接口文档：swaggo</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p><img src="/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/image-20210530180905611.png" alt="项目架构"></p>
<p>db是数据库的初始化 以及建表的sql语句（gorm给生成的 orm真是懒狗偷懒的好帮手(好耶)）</p>
<p>docs是swaggo生成接口文档的几个文件，有一说一这玩意是真的好用(同样是懒狗必备神器)，再也不用自己找前端页面自己改名字写js了。</p>
<p>kcommon是一些公用的基础文件，例如缓存的初始化，jwt的生成与解析等都放在这里。(common前面加k是个人习惯，后面的几个包也是加了k的，正确的写法是不加k的)</p>
<p>接下来的三个包就不用细说了~相信有mvc开发经验的小伙伴都能理解是干什么的</p>
<p>log包是日志文件存放的地方，日志里会记录一下程序上的错误，例如数据库连接出错什么的。</p>
<p>static是放前端页面的地方，然而这里什么都没放(因为没有前端~有swaggo就是可以为所欲为)</p>
<p>然后的go.mod是版本的控制管理文件，不细说。</p>
<p>main.go就是项目的入口啦。 </p>
<h2 id="项目详细介绍"><a href="#项目详细介绍" class="headerlink" title="项目详细介绍"></a>项目详细介绍</h2><p>这个或许不应该叫项目特点，应该是在写之前就规划好的要写什么。</p>
<p>但现在已经写完啦，所以就当成特点来写了。</p>
<p>因为涉及到了实验室的报名(虽然最后也不一定用这个)，因此在代码展示上只会放一些controller层的代码和一些不重要的代码。(我本人是十分推崇开源的。)</p>
<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;SignUp/db&quot;</span></span><br><span class="line">	_ <span class="string">&quot;SignUp/docs&quot;</span></span><br><span class="line">	<span class="string">&quot;SignUp/kcommon&quot;</span></span><br><span class="line">	<span class="string">&quot;SignUp/kcontroller&quot;</span></span><br><span class="line">	<span class="string">&quot;go-Kirby-utils/klog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defAddr = <span class="string">&quot;:8080&quot;</span></span><br><span class="line">	ServiceStartError = <span class="string">&quot;服务未启动!&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//控制台输出监听端口信息</span></span><br><span class="line">	klog.Info(<span class="string">&quot;Init Addr Of SignUp&quot;</span>,defAddr)</span><br><span class="line">	<span class="comment">//获取全局路由</span></span><br><span class="line">	r := kcontroller.GlobalRouter()</span><br><span class="line">	<span class="comment">//加载静态文件</span></span><br><span class="line">	kcontroller.GlobStatic(r)</span><br><span class="line">	<span class="comment">//开始监听端口</span></span><br><span class="line">	err := r.Run(defAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kcommon.GlobalLog.Fatalf(ServiceStartError)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//log初始化</span></span><br><span class="line">	kcommon.InitKlog()</span><br><span class="line">	<span class="comment">//缓存初始化</span></span><br><span class="line">	kcommon.InitKcache()</span><br><span class="line">	<span class="comment">//数据库初始化</span></span><br><span class="line">	db.InitDb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那个加载静态文件是初始化static那个包的，然鹅那个包没有东西……所以这个函数可以忽略它，后面如果放前端页面的话才会用到它。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">limit := r.Group(<span class="string">&quot;/limit&quot;</span>)</span><br><span class="line">administrator := r.Group(<span class="string">&quot;/admin&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>将路由分为三个路由组，全局路由、带限制的路由limit和管理员路由administrator</p>
<h3 id="学生端"><a href="#学生端" class="headerlink" title="学生端"></a>学生端</h3><p>首先来看报名的信息应该有哪些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="keyword">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Email <span class="keyword">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">	Phone <span class="keyword">string</span> <span class="string">`json:&quot;phone&quot;`</span></span><br><span class="line">	Numbers <span class="keyword">string</span> <span class="string">`json:&quot;numbers&quot;`</span></span><br><span class="line">	Class <span class="keyword">string</span> <span class="string">`json:&quot;class&quot;`</span></span><br><span class="line">	Status Status <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里的Status是对int重命名，用来控制学生的报名状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>报名状态写成const和数组，以下标形式进行控制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	SignUpSuccess Status = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	FirstFail</span><br><span class="line">	FirstSuccess</span><br><span class="line">	SecondFail</span><br><span class="line">	SecondSuccess</span><br><span class="line">	ThirdFail</span><br><span class="line">	ThirdSuccess</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	StatusResult = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;报名失败&quot;</span>,<span class="string">&quot;报名成功&quot;</span>, <span class="string">&quot;一面未通过&quot;</span>, <span class="string">&quot;一面通过&quot;</span>, <span class="string">&quot;二面未通过&quot;</span>, <span class="string">&quot;二面通过&quot;</span>,<span class="string">&quot;三面未通过&quot;</span>,<span class="string">&quot;三面通过&quot;</span>&#125;</span><br><span class="line">	StatusAll = [...]Status&#123;<span class="number">0</span>,SignUpSuccess,FirstFail,FirstSuccess,SecondFail,SecondSuccess,ThirdFail,ThirdSuccess&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>而学生结构体里设置了邮箱，手机号码和学号，这三项在数据库里是不可以重复的。</p>
<h4 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h4><p>学生应当可以输入自己的信息进行报名。</p>
<p>由前端进行数据的校验(正则)。</p>
<p>后端会去数据库对比数据，当重要数据重复时会提示不可报名。</p>
<p>如果报名成功的话，会将结构体里的Status直接设置为1，即报名成功。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignUp</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//拿信息</span></span><br><span class="line">	phone := c.PostForm(<span class="string">&quot;Phone&quot;</span>)</span><br><span class="line">	Email := c.PostForm(<span class="string">&quot;Email&quot;</span>)</span><br><span class="line">	Nums := c.PostForm(<span class="string">&quot;Nums&quot;</span>)</span><br><span class="line">	<span class="comment">//将数据传到后面去进行对比，如果数据可用则放行。</span></span><br><span class="line">	<span class="keyword">if</span> ok, v := kservice.Check(phone, Email, Nums); !ok &#123;</span><br><span class="line">		WriteResp(c, Message, v)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拿到必要的信息</span></span><br><span class="line">	name := c.PostForm(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">	class := c.PostForm(<span class="string">&quot;Class&quot;</span>)</span><br><span class="line">	<span class="comment">//直接存</span></span><br><span class="line">	_, v := kservice.SaveStudent(name, phone, Email, Nums, class)</span><br><span class="line">	<span class="comment">//写回信息</span></span><br><span class="line">	WriteResp(c, Message, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的WriteResp实际上是对c.JSON()很简单的封装，为了方便自己而已。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResp</span><span class="params">(c *gin.Context,name, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK,gin.H&#123;</span><br><span class="line">		name: msg,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>这里的两个查询都是学生在报名之后，查询自己的面试状态时使用的。</p>
<h5 id="通过手机号码进行查询"><a href="#通过手机号码进行查询" class="headerlink" title="通过手机号码进行查询"></a>通过手机号码进行查询</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStudentByPhone</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	phone := c.PostForm(<span class="string">&quot;SPhone&quot;</span>)</span><br><span class="line">	name := c.PostForm(<span class="string">&quot;SName&quot;</span>)</span><br><span class="line">	Msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	ctx,cancel := context.WithTimeout(context.Background(),<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> kservice.SearchStudentByPhone(ctx,name, phone,Msg)</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			WriteResp(c,Message,TimeOut)</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> str := &lt;- Msg:</span><br><span class="line">			WriteResp(c,Message,str)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了context进行超时的判断。</p>
<p>在刚开始写的时候是没有使用到context的，后面完善的时候才做了这样的改动。</p>
<p>刚开始的修改还是在service层修改，怎么也改不对，头疼一早上。</p>
<p>而中午去干饭的路上竟然想通了(可见反内卷是多么重要啊)</p>
<p>以后出bug就去干饭！</p>
<p>果然，context还是要搭配goroutine和channel一起食用才好玩啊。</p>
<h5 id="通过邮箱进行查询"><a href="#通过邮箱进行查询" class="headerlink" title="通过邮箱进行查询"></a>通过邮箱进行查询</h5><p>这个查询和上文的手机号查询逻辑是一样的，只不过把手机号换成了邮箱。</p>
<p><em><strong>重点来了！</strong></em>当学生被告知可以查询自己的面试结果时，必然有很多人同时想知道自己过了没，那么这一瞬间会有很多(bushi)(估计也就百来个)的请求打到数据库去，那这一瞬间对于数据库就会造成很大的压力。</p>
<p>虽然并发量是可以预估的，不会有多大，但是肯定会导致响应结果变慢。而这点并发量都会出问题，那如果请求是千万级的，甚至上亿的呢。</p>
<p>数据库的压力是可想而知的。</p>
<p>那么这里是怎么解决的呢？</p>
<p>那就是~<em><strong>缓存</strong></em>啦</p>
<p>这里我有做缓存，还记得main.go里的缓存初始化嘛？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存初始化</span></span><br><span class="line">kcommon.InitKcache()</span><br></pre></td></tr></table></figure>

<p><em><strong>当数据被请求时，首先会去查询缓存里是否有这个数据，如果有的话，直接把拿到的数据返回给查询者，根本不用走数据库。</strong></em></p>
<p>也就是说，在小于500的并发量情况下，每一个人都访问一次自己的面试状态后，缓存里还没装满，以后再查询的时候，全部走缓存，数据库就可以歇着了。</p>
<p>(数据库：笑死，根本没压力)</p>
<p>(缓存：？)</p>
<p>而这里设置的是，当数据在缓存里没击中时，才会去数据库里拿数据，然后把这条数据塞进缓存里。</p>
<p>也可以调整为，当报名后，就直接把数据放进缓存里，应对随时可能出现的请求~</p>
<h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p>管理员登录后，可以进行一系列的操作。</p>
<p>这里为了防止输入路由就直接可以进入管理员界面，做了JWT认证，当请求路由而不带认证的Token时，则不予放行。</p>
<h4 id="获取学生数据"><a href="#获取学生数据" class="headerlink" title="获取学生数据"></a>获取学生数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//获取请求中所请求的页数</span></span><br><span class="line">	pageStr := c.PostForm(<span class="string">&quot;pageNow&quot;</span>)</span><br><span class="line">	<span class="comment">//转换为整形</span></span><br><span class="line">	page,err := strconv.Atoi(pageStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kcommon.GlobalLog.Infof(err)</span><br><span class="line">		WriteResp(c,Message,GetDataErr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取数据库总页数</span></span><br><span class="line">	cnt := kservice.Count()</span><br><span class="line">	<span class="comment">//进行计算总共需要多少页展示 这里设置的一页展示十条数据(defCount) </span></span><br><span class="line">	<span class="keyword">if</span> cnt%defCount == <span class="number">0</span> &#123;</span><br><span class="line">		cnt /= defCount</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		cnt = cnt / defCount + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> page &gt; cnt &#123;</span><br><span class="line">		WriteResp(c,Message,PageErr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//按照分页获取数据</span></span><br><span class="line">	res,err := kservice.GetData(defCount,(page - <span class="number">1</span>) * defCount)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kcommon.GlobalLog.Infof(err)</span><br><span class="line">		WriteResp(c,Message,GetDataErr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusOK,gin.H&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span>:cnt,</span><br><span class="line">		<span class="string">&quot;res&quot;</span>:res,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/image-20210531101054576.png" alt="请求到的数据"></p>
<p>(PS：图中的数据是为了测试 自己写了循环生成的，没有实际意义。)</p>
<h4 id="改变面试状态"><a href="#改变面试状态" class="headerlink" title="改变面试状态"></a>改变面试状态</h4><p>当面试结束后，管理员需要去改变面试的状态，以便学生可以查到自己面试是否通过。</p>
<p>这个也没有什么好说的，在数据库更新字段而已。</p>
<p>需要注意的是，当数据库里的字段发生更新，缓存里也应该一起更新。</p>
<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>这里就是管理员需要做的一些操作，例如有人没有报名成功，或者填错信息，在这里去进行更改。</p>
<p>同样需要注意的是，在更新数据库时，要更新缓存里的数据。</p>
<p>而且，对缓存的更新应当在数据库的更新之前。关于缓存的这种设计思路，我就不细说了，网上有很多。</p>
<h4 id="打开-关闭-服务"><a href="#打开-关闭-服务" class="headerlink" title="打开/关闭 服务"></a>打开/关闭 服务</h4><p>网站对学生端暴露的服务应当是可以打开与关闭的。</p>
<p>在没有到预定的时间时，学生的报名或者查询应该是不可用使用的。</p>
<p>而到时间后，管理员开启服务，学生可以进行报名或者查询。</p>
<p>这里的实现也超级简单，就是设置一个bool型的全局变量，写一个中间件去访问这个变量就好，只有这个变量为true时，网站才会提供服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间控制服务是否开启的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerOpen</span><span class="params">()</span> <span class="title">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">//如果控制服务开关的变量为false 则不予服务</span></span><br><span class="line">		<span class="keyword">if</span> !kcommon.ServerOpen &#123;</span><br><span class="line">			WriteResp(c,Message,kcommon.NotOpen)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//放行</span></span><br><span class="line">			c.Next()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="基于IP控制访问次数的中间件"><a href="#基于IP控制访问次数的中间件" class="headerlink" title="基于IP控制访问次数的中间件"></a>基于IP控制访问次数的中间件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IPLimit <span class="keyword">struct</span> &#123;</span><br><span class="line">	IP   <span class="keyword">string</span></span><br><span class="line">	time time.Time</span><br><span class="line">	nums <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上下文中获取到来访者的IP地址，然后把IP作为key放进一个新的缓存里。</p>
<p>如果缓存里没有这个ip，说明是第一次访问。那么将其加入缓存，时间为当前时间，nums置为0.</p>
<p>当它在缓存里时，说明这个ip已经访问过了，会将nums++，然后去做个判断。</p>
<p>当这个ip在一定的时间里访问次数达到一定数量时，将会被判定为恶意攻击，然后会被禁掉一定时间不能访问网站。</p>
<p>这个的实现是对结构体里的time进行一定的操作，而后面在访问到时就会被判断到，从而达到禁掉的效果。</p>
<h3 id="基于令牌桶控制访问次数的中间件"><a href="#基于令牌桶控制访问次数的中间件" class="headerlink" title="基于令牌桶控制访问次数的中间件"></a>基于令牌桶控制访问次数的中间件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimitMiddleware</span><span class="params">(fillInterval time.Duration, <span class="built_in">cap</span> <span class="keyword">int64</span>)</span> <span class="title">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   bucket := ratelimit.NewBucket(fillInterval, <span class="built_in">cap</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 如果取不到令牌就中断本次请求返回 rate limit...</span></span><br><span class="line">      <span class="keyword">if</span> bucket.TakeAvailable(<span class="number">1</span>) &lt; <span class="number">1</span> &#123;</span><br><span class="line">         c.JSON(http.StatusOK,gin.H&#123;</span><br><span class="line">            Message:TooManyVisiters ,</span><br><span class="line">         &#125;)</span><br><span class="line">         c.Abort()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.Next()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是参照网上的写法，也是用的第三方库。</p>
<p>实际上这个封装的就很简单，开箱即用。</p>
<p>令牌桶就是一个桶里生成一定数量的令牌，当桶里还有令牌时，那么来访者取走一个，可以访问网站。</p>
<p>如果桶里的令牌都被取走了，那么来访者就会被告知当前访问人数过多，请稍后再访问。</p>
<p>前面基于IP的中间件是防止个人进行恶意攻击而限流，而这个是根据总的访问量来限流。</p>
<p>比如，我设置了令牌桶的大小为60个，一秒钟补充5个，那么，当桶里的令牌都被取走后，一秒钟补充了5个，网站还可以为5个来访者进行服务。</p>
<p>桶的大小和补充速率的设定是很重要的事情。</p>
<p>设置大了，自己的服务器扛不住压力；小了，用户的体验将会大打折扣。</p>
<p>因此，在使用令牌桶时，需要仔细斟酌这两个数值的设置。</p>
<h3 id="基于JWT的身份认证"><a href="#基于JWT的身份认证" class="headerlink" title="基于JWT的身份认证"></a>基于JWT的身份认证</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTAuthMiddleware</span><span class="params">()</span> <span class="title">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      token := c.PostForm(<span class="string">&quot;Token&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> token == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">         WriteResp(c,Message,NotLogin)</span><br><span class="line">         c.Abort()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      _,err := kcommon.ParseToken(token)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         WriteResp(c,Message,JWTErr)</span><br><span class="line">         c.Abort()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.Next()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JWT是什么我就不多说了，想学习的小伙伴可以自己去搜，大把的资源。</p>
<p>当来访者请求未携带token，会被判断为未登录。</p>
<p>错误时，提示token错误，不能登录。</p>
<p>当token正确，才可以执行想要的功能。</p>
<p>放一段解析token的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ParseToken 解析JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="keyword">string</span>)</span> <span class="params">(*MyClaims, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 解析token</span></span><br><span class="line">   token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> MySecret, <span class="literal">nil</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="comment">// 校验token</span></span><br><span class="line">      <span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些就是这个项目里我认为还算有营养的点啦</p>
<p>毕竟这个项目确实很简单，没有太多值得细细说的。</p>
<p>其实说起来，写的也并不好，还有许多可以规范的点。</p>
<p>例如，model层的返回数据格式可以统一起来，然后加一个异步访问数据库的控制函数，可以更好的应对高并发的场景。</p>
<p>而一些const，都采用了string的返回值，但是在与前端大佬的沟通过后，觉得可以设定一些状态码用以返回。</p>
<p>而超时控制、结构划分、缓存、日志的使用这些，都还是可以细化优化的，不过也就不再搞了，准备开始写官网。</p>
<p>作为官网的一个模块，自己第一个项目的起步，也算还不错。</p>
<p>记录在这里，是对自己项目的一个总结反思，也是一种分享。</p>
<p>希望对看到这里的你有所帮助~</p>
<p>最后晒一下儿童节礼物(半价淘来就是舒服)</p>
<p><img src="/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/OS.jpg" alt="OS"></p>
]]></content>
      <categories>
        <category>golang</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>web</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>让你的项目高档起来——添加邮箱验证码功能</title>
    <url>/2021/06/03/%E8%AE%A9%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%AB%98%E6%A1%A3%E8%B5%B7%E6%9D%A5%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在做项目的时候，如果你想把项目做的高档一点，那么在注册的时候发送一个验证码是必不可少的。</p>
<p>短信验证码是要收费的，给钱是不可能给钱的，只能靠白嫖才能维持的了生活这亚子(bushi)。</p>
<p>那就使用邮箱发送验证码吧。</p>
<p>本文来介绍一下如何在你的go项目中添加这个功能或完善这个功能。</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>本文默认你对smtp协议有所了解。</p>
<p>本文的邮箱发送基于gomail这个包。</p>
<h2 id="配置邮箱"><a href="#配置邮箱" class="headerlink" title="配置邮箱"></a>配置邮箱</h2><p>因为不是企业邮箱，我们个人做的话，不会像在公司一样，有其他人把这个事情做好，你只要调api就好了。</p>
<p>但是问题不大，自己动手，丰衣足食。</p>
<p>这里介绍两种配置方法。</p>
<h3 id="qq邮箱"><a href="#qq邮箱" class="headerlink" title="qq邮箱"></a>qq邮箱</h3><p><a href="https://blog.csdn.net/ifubing/article/details/104499005?ops_request_misc=&request_id=&biz_id=102&utm_term=stmp">开通qq邮箱的smtp服务的流程详情_pyhui的技术博客-CSDN博客</a></p>
<p>使用qq邮箱的限制会比较大，不能连续发还是怎么滴，总之自己玩玩还可以，用在不会落地的项目里也可以，千万别用在上线的项目里。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>这种方法需要你有一个域名而且对域名备案。</p>
<p>好处是没有那么多限制。</p>
<p>而且每天有200封免费邮件的额度(白嫖怪狂喜)</p>
<p>还可以监控追踪邮件发送情况。</p>
<p><a href="https://blog.csdn.net/u014633966/article/details/87877846">利用阿里云邮件推送免费发邮件，每天免费200封，速度快，还高大上_潜心修炼–记录点滴-CSDN博客_邮件推送</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>邮箱配置完成后，我们会拥有一个发信邮箱和密码，将这个记下来。</p>
<p>首先是结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EmailConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Host        <span class="keyword">string</span> <span class="string">`json:&quot;host&quot; yaml:&quot;host&quot;`</span></span><br><span class="line">	Port        <span class="keyword">int</span>    <span class="string">`json:&quot;port&quot; yaml:&quot;port&quot;`</span></span><br><span class="line">	Email       <span class="keyword">string</span> <span class="string">`json:&quot;kemail&quot; yaml:&quot;kemail&quot;`</span></span><br><span class="line">	Pwd         <span class="keyword">string</span> <span class="string">`json:&quot;pwd&quot; yaml:&quot;pwd&quot;`</span></span><br><span class="line">	ServerName  <span class="keyword">string</span> <span class="string">`json:&quot;serverName&quot; yaml:&quot;serverName&quot;`</span></span><br><span class="line">	ContentType <span class="keyword">string</span> <span class="string">`json:&quot;contentType&quot; yaml:&quot;contentType&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmailClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	cfg    *EmailConfig</span><br><span class="line">	helper *gomail.Dialer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个是邮箱的配置信息，一个是EmailClient，用来发信。</p>
<p>然后是初始化配置信息结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailConfig</span><span class="params">(Host, Email, Pwd <span class="keyword">string</span>, Port <span class="keyword">int</span>)</span> <span class="params">(cfg *EmailConfig)</span></span> &#123;</span><br><span class="line">	email :=  EmailConfig&#123;</span><br><span class="line">		Host: Host,</span><br><span class="line">		Port: Port,</span><br><span class="line">		Email: Email,</span><br><span class="line">		Pwd: Pwd,</span><br><span class="line">		ServerName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">		ContentType: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也没有什么好讲的，把配置信息塞进去就行了。</p>
<p>Host填邮箱服务对应的host，例如阿里云就是smtpdm.aliyun.com</p>
<p>而Port同理，按照服务厂商给的端口填写。</p>
<p>开启客户端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NewEmailClient = <span class="function"><span class="keyword">func</span><span class="params">(cfg *EmailConfig)</span> *<span class="title">EmailClient</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> cfg.ServerName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      cfg.ServerName = defServerName</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> cfg.ContentType == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      cfg.ContentType = sendBody</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;EmailClient&#123;</span><br><span class="line">      cfg:    cfg,</span><br><span class="line">      helper: gomail.NewDialer(cfg.Host, cfg.Port, cfg.Email, cfg.Pwd),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的一些consts：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fromName    = <span class="string">&quot;From&quot;</span></span><br><span class="line">sendTo      = <span class="string">&quot;To&quot;</span></span><br><span class="line">sendSubject = <span class="string">&quot;subject&quot;</span></span><br><span class="line">sendBody    = <span class="string">&quot;text/html&quot;</span></span><br></pre></td></tr></table></figure>

<p>defServeName按照自己的喜好填写即可。</p>
<p>在获得一个客户端后，我们就可以开始写发信方法了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *EmailClient)</span> <span class="title">newMessage</span><span class="params">(subject, body <span class="keyword">string</span>, mailTo ...<span class="keyword">string</span>)</span> *<span class="title">gomail</span>.<span class="title">Message</span></span> &#123;</span><br><span class="line">   message := gomail.NewMessage()</span><br><span class="line">   message.SetHeader(fromName, es.cfg.Email, es.cfg.ServerName)</span><br><span class="line">   message.SetHeader(sendTo, mailTo...)</span><br><span class="line">   message.SetHeader(sendSubject, subject)</span><br><span class="line">   message.SetBody(sendBody, body)</span><br><span class="line">   <span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *EmailClient)</span> <span class="title">SendEmail</span><span class="params">(subject, body <span class="keyword">string</span>, mailTo ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   err := es.helper.DialAndSend(es.newMessage(subject, body, mailTo...))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要发信，直接调用SendEmail即可。参数是 标题、邮件主体、收信邮箱。</p>
<p>代码也十分易于理解。</p>
<p>至此，顺利的话，收信邮箱已经躺好了一封邮件等你接收~</p>
<p>如果对此有疑问的话，可以移步这里：<a href="https://github.com/Luyuan-919/go-kirby-utils">Luyuan-919/go-kirby-utils (github.com)</a></p>
<p>在这个开源的库里，有我已经封装好的一系列工具，刚才介绍的代码都在其中的kemail里。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>说完了基本的发信demo，就可以将其应用在自己的项目中了。</p>
<p>首先我们来看看需求：</p>
<p>我们需要在有需要的时候将邮件发送至指定的邮箱，邮件里需要包含我们给出的验证码，用户在拿到验证码之后会使用这个验证码进行注册或修改密码等服务。</p>
<p>验证码不可能发出去就一直可以用，因此我们需要设置过期时间，这个时间一般是五分钟。</p>
<p>在用户验证完验证码后，我们要对验证码进行删除。</p>
<p>为了防止用户发送完验证码后不使用，过期的验证码堆积在我们的内存里，我们还需要定时清除过期的验证码。</p>
<p>ok，基本需求就是这些，来写代码即可。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EmailCodeType <span class="keyword">struct</span> &#123;</span><br><span class="line">   Code <span class="keyword">string</span></span><br><span class="line">   Time time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   Email *kemail.EmailClient</span><br><span class="line">   EmailTicker *time.Ticker</span><br><span class="line">   DefTickerTime = <span class="number">12</span> * time.Hour</span><br><span class="line">   Mu sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   EmailCode = <span class="keyword">map</span>[<span class="keyword">string</span>]EmailCodeType&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEmail</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cfg := config.GlobalCfg()</span><br><span class="line">   emailCfg := cfg.EmailConfig</span><br><span class="line">   c := kemail.NewEmailConfig(emailCfg.Host,emailCfg.Email,emailCfg.Pwd,emailCfg.Port)</span><br><span class="line">   Email = kemail.NewEmailClient(c)</span><br><span class="line">   EmailTicker = time.NewTicker(DefTickerTime)</span><br><span class="line">   <span class="keyword">go</span> EmailCodeClean()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们选择map来储存验证码。</p>
<p>在项目里Init一个发信客户端。</p>
<p>通过配置文件(yaml)的方式填写邮箱的配置信息。</p>
<h3 id="发信"><a href="#发信" class="headerlink" title="发信"></a>发信</h3><p>当用户选择需要发送验证码服务的时候，我们先得产生一个验证码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendCode</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//如果该邮箱已经在map里且时间未过期 则返回false 不予发送</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := common.EmailCode[email]; ok &#123;</span><br><span class="line">		<span class="keyword">if</span> time.Since(common.EmailCode[email].Time) &lt; DefExpireTime &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义结构体</span></span><br><span class="line">	<span class="keyword">var</span> c common.EmailCodeType</span><br><span class="line">	<span class="comment">//获取验证码</span></span><br><span class="line">	c.Code = GetVerificationCode()</span><br><span class="line">	<span class="comment">//时间设置为当前时间</span></span><br><span class="line">	c.Time = time.Now()</span><br><span class="line">	<span class="comment">//在map里存下</span></span><br><span class="line">	common.EmailCode[email] = c</span><br><span class="line">	<span class="comment">//调用方法,发信</span></span><br><span class="line">	err := common.Email.SendEmail(Code,GetBody(c.Code),email)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		common.GlobalLog.Infof(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取邮件内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBody</span><span class="params">(code <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(common.EmailHtmlFmt,Code,config.GlobalCfg().ServerName,code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个验证码 验证码长度设置为6位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetVerificationCode</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> krandom.CreateRandomNumber(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那个common.EmailHtmlFmt是自定义的邮件模板，其实就是写好的html，网上有很多，搜索邮件html模板即可。</p>
<p>这里说一下这个获取验证码的方法，它也在我开源的那个工具包里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateRandomNumber</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>)</span>  <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> numbers = []<span class="keyword">byte</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> container <span class="keyword">string</span></span><br><span class="line">	length := bytes.NewReader(numbers).Len()</span><br><span class="line">	x := big.NewInt(<span class="keyword">int64</span>(length))</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="built_in">len</span>;i++&#123;</span><br><span class="line">		random,_ := rand.Int(rand.Reader,x)</span><br><span class="line">		container += fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,numbers[random.Int64()])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> container</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个产生的随机数是随机程度比较高的。</p>
<p>到这一步，我们的邮件就已经发送到了收信者的邮箱里了。</p>
<h3 id="处理验证码"><a href="#处理验证码" class="headerlink" title="处理验证码"></a>处理验证码</h3><p>当用户收到验证码后，我们要做的是校验验证码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当发来的验证码和本地存的验证码不一样 会返回验证码错误的数据.</span></span><br><span class="line">	<span class="keyword">if</span> common.EmailCode[email].Code != code&#123;</span><br><span class="line">		WriteJsonCode(c,Code,CodeNotMatch)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果发来的时间已经超过设置的超时时间,那么返回超时错误.</span></span><br><span class="line">	<span class="keyword">if</span> time.Since(common.EmailCode[email].Time) &gt; DefExpiredTime &#123;</span><br><span class="line">		WriteJsonCode(c,Code,CodeTimeOut)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	GlobalMu.Lock()</span><br><span class="line">	<span class="comment">//验证成功 在map里删除此验证码</span></span><br><span class="line">	<span class="built_in">delete</span>(common.EmailCode,email)</span><br><span class="line">	GlobalMu.Unlock()</span><br><span class="line">	do....</span><br></pre></td></tr></table></figure>

<p>通过这套流程 即可校验验证码。</p>
<h3 id="处理过期验证码"><a href="#处理过期验证码" class="headerlink" title="处理过期验证码"></a>处理过期验证码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmailCodeClean</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		&lt;- EmailTicker.C</span><br><span class="line">		<span class="keyword">for</span> k,v := <span class="keyword">range</span> EmailCode&#123;</span><br><span class="line">			<span class="keyword">if</span> time.Since(v.Time) &gt; time.Minute*<span class="number">5</span> &#123;</span><br><span class="line">				Mu.Lock()</span><br><span class="line">				<span class="built_in">delete</span>(EmailCode,k)</span><br><span class="line">				Mu.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们开启一个ticker定时清除过期的验证码即可。</p>
<p>因为我这个项目做出来后，可想而知的用户量不会太大，因此我就放心的把清理时间设置为12小时清理一次。</p>
<p>如果你的项目有可能会一天的发信量突破200而你又不想花钱，那还可以写一个中间件，统计发信的次数，当一天的发信量到一定量时，停止服务。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上就是如何在你的项目里加上验证码功能。</p>
<p>如果你有疑问或者见解，都可以加我的qq讨论。</p>
<p>感谢你能看到这里，希望对你有所帮助~</p>
]]></content>
      <categories>
        <category>golang</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>验证码功能</tag>
      </tags>
  </entry>
</search>
