<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang项目——纳新报名网站</title>
    <url>/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="一个小项目"><a href="#一个小项目" class="headerlink" title="一个小项目~"></a>一个小项目~</h2><p>离准备面试的时间只剩下半年左右的时间了，而身为菜鸟的我还没有做拿得出手的项目。</p>
<p>于是开始考虑该做点什么东西才能忽悠(bushi)面试官。</p>
<p>想来想去，给实验室做个官网吧，当作自己的第一个项目。</p>
<p>可是之前没有写过大型的网站，脑壳疼。</p>
<p>那就先写个纳新报名的网站吧！实验室每年都纳新，实用性有了。后面把这玩意集成到官网里去，相当于官网完成一个部分了(摸鱼)。</p>
<p>说干就干！</p>
<p>然后……三天以后……完成了……</p>
<p>嗯……简单的过分。</p>
<p>正好又在周末摸鱼把个人博客搭起来了，那就在此记录一番。</p>
<h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><p>web框架：gin</p>
<p>数据库：mysql</p>
<p>数据库交互：gorm</p>
<p>接口文档：swaggo</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p><img src="/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/image-20210530180905611.png" alt="项目架构"></p>
<p>db是数据库的初始化 以及建表的sql语句（gorm给生成的 orm真是懒狗偷懒的好帮手(好耶)）</p>
<p>docs是swaggo生成接口文档的几个文件，有一说一这玩意是真的好用(同样是懒狗必备神器)，再也不用自己找前端页面自己改名字写js了。</p>
<p>kcommon是一些公用的基础文件，例如缓存的初始化，jwt的生成与解析等都放在这里。(common前面加k是个人习惯，后面的几个包也是加了k的，正确的写法是不加k的)</p>
<p>接下来的三个包就不用细说了~相信有mvc开发经验的小伙伴都能理解是干什么的</p>
<p>log包是日志文件存放的地方，日志里会记录一下程序上的错误，例如数据库连接出错什么的。</p>
<p>static是放前端页面的地方，然而这里什么都没放(因为没有前端~有swaggo就是可以为所欲为)</p>
<p>然后的go.mod是版本的控制管理文件，不细说。</p>
<p>main.go就是项目的入口啦。 </p>
<h2 id="项目详细介绍"><a href="#项目详细介绍" class="headerlink" title="项目详细介绍"></a>项目详细介绍</h2><p>这个或许不应该叫项目特点，应该是在写之前就规划好的要写什么。</p>
<p>但现在已经写完啦，所以就当成特点来写了。</p>
<p>因为涉及到了实验室的报名(虽然最后也不一定用这个)，因此在代码展示上只会放一些controller层的代码和一些不重要的代码。(我本人是十分推崇开源的。)</p>
<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;SignUp/db&quot;</span></span><br><span class="line">	_ <span class="string">&quot;SignUp/docs&quot;</span></span><br><span class="line">	<span class="string">&quot;SignUp/kcommon&quot;</span></span><br><span class="line">	<span class="string">&quot;SignUp/kcontroller&quot;</span></span><br><span class="line">	<span class="string">&quot;go-Kirby-utils/klog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defAddr = <span class="string">&quot;:8080&quot;</span></span><br><span class="line">	ServiceStartError = <span class="string">&quot;服务未启动!&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//控制台输出监听端口信息</span></span><br><span class="line">	klog.Info(<span class="string">&quot;Init Addr Of SignUp&quot;</span>,defAddr)</span><br><span class="line">	<span class="comment">//获取全局路由</span></span><br><span class="line">	r := kcontroller.GlobalRouter()</span><br><span class="line">	<span class="comment">//加载静态文件</span></span><br><span class="line">	kcontroller.GlobStatic(r)</span><br><span class="line">	<span class="comment">//开始监听端口</span></span><br><span class="line">	err := r.Run(defAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kcommon.GlobalLog.Fatalf(ServiceStartError)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//log初始化</span></span><br><span class="line">	kcommon.InitKlog()</span><br><span class="line">	<span class="comment">//缓存初始化</span></span><br><span class="line">	kcommon.InitKcache()</span><br><span class="line">	<span class="comment">//数据库初始化</span></span><br><span class="line">	db.InitDb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那个加载静态文件是初始化static那个包的，然鹅那个包没有东西……所以这个函数可以忽略它，后面如果放前端页面的话才会用到它。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">limit := r.Group(<span class="string">&quot;/limit&quot;</span>)</span><br><span class="line">administrator := r.Group(<span class="string">&quot;/admin&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>将路由分为三个路由组，全局路由、带限制的路由limit和管理员路由administrator</p>
<h3 id="学生端"><a href="#学生端" class="headerlink" title="学生端"></a>学生端</h3><p>首先来看报名的信息应该有哪些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="keyword">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Email <span class="keyword">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">	Phone <span class="keyword">string</span> <span class="string">`json:&quot;phone&quot;`</span></span><br><span class="line">	Numbers <span class="keyword">string</span> <span class="string">`json:&quot;numbers&quot;`</span></span><br><span class="line">	Class <span class="keyword">string</span> <span class="string">`json:&quot;class&quot;`</span></span><br><span class="line">	Status Status <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里的Status是对int重命名，用来控制学生的报名状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>报名状态写成const和数组，以下标形式进行控制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	SignUpSuccess Status = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	FirstFail</span><br><span class="line">	FirstSuccess</span><br><span class="line">	SecondFail</span><br><span class="line">	SecondSuccess</span><br><span class="line">	ThirdFail</span><br><span class="line">	ThirdSuccess</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	StatusResult = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;报名失败&quot;</span>,<span class="string">&quot;报名成功&quot;</span>, <span class="string">&quot;一面未通过&quot;</span>, <span class="string">&quot;一面通过&quot;</span>, <span class="string">&quot;二面未通过&quot;</span>, <span class="string">&quot;二面通过&quot;</span>,<span class="string">&quot;三面未通过&quot;</span>,<span class="string">&quot;三面通过&quot;</span>&#125;</span><br><span class="line">	StatusAll = [...]Status&#123;<span class="number">0</span>,SignUpSuccess,FirstFail,FirstSuccess,SecondFail,SecondSuccess,ThirdFail,ThirdSuccess&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>而学生结构体里设置了邮箱，手机号码和学号，这三项在数据库里是不可以重复的。</p>
<h4 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h4><p>学生应当可以输入自己的信息进行报名。</p>
<p>由前端进行数据的校验(正则)。</p>
<p>后端会去数据库对比数据，当重要数据重复时会提示不可报名。</p>
<p>如果报名成功的话，会将结构体里的Status直接设置为1，即报名成功。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignUp</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//拿信息</span></span><br><span class="line">	phone := c.PostForm(<span class="string">&quot;Phone&quot;</span>)</span><br><span class="line">	Email := c.PostForm(<span class="string">&quot;Email&quot;</span>)</span><br><span class="line">	Nums := c.PostForm(<span class="string">&quot;Nums&quot;</span>)</span><br><span class="line">	<span class="comment">//将数据传到后面去进行对比，如果数据可用则放行。</span></span><br><span class="line">	<span class="keyword">if</span> ok, v := kservice.Check(phone, Email, Nums); !ok &#123;</span><br><span class="line">		WriteResp(c, Message, v)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拿到必要的信息</span></span><br><span class="line">	name := c.PostForm(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">	class := c.PostForm(<span class="string">&quot;Class&quot;</span>)</span><br><span class="line">	<span class="comment">//直接存</span></span><br><span class="line">	_, v := kservice.SaveStudent(name, phone, Email, Nums, class)</span><br><span class="line">	<span class="comment">//写回信息</span></span><br><span class="line">	WriteResp(c, Message, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的WriteResp实际上是对c.JSON()很简单的封装，为了方便自己而已。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResp</span><span class="params">(c *gin.Context,name, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK,gin.H&#123;</span><br><span class="line">		name: msg,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>这里的两个查询都是学生在报名之后，查询自己的面试状态时使用的。</p>
<h5 id="通过手机号码进行查询"><a href="#通过手机号码进行查询" class="headerlink" title="通过手机号码进行查询"></a>通过手机号码进行查询</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStudentByPhone</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	phone := c.PostForm(<span class="string">&quot;SPhone&quot;</span>)</span><br><span class="line">	name := c.PostForm(<span class="string">&quot;SName&quot;</span>)</span><br><span class="line">	Msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	ctx,cancel := context.WithTimeout(context.Background(),<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> kservice.SearchStudentByPhone(ctx,name, phone,Msg)</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			WriteResp(c,Message,TimeOut)</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> str := &lt;- Msg:</span><br><span class="line">			WriteResp(c,Message,str)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了context进行超时的判断。</p>
<p>在刚开始写的时候是没有使用到context的，后面完善的时候才做了这样的改动。</p>
<p>刚开始的修改还是在service层修改，怎么也改不对，头疼一早上。</p>
<p>而中午去干饭的路上竟然想通了(可见反内卷是多么重要啊)</p>
<p>以后出bug就去干饭！</p>
<p>果然，context还是要搭配goroutine和channel一起食用才好玩啊。</p>
<h5 id="通过邮箱进行查询"><a href="#通过邮箱进行查询" class="headerlink" title="通过邮箱进行查询"></a>通过邮箱进行查询</h5><p>这个查询和上文的手机号查询逻辑是一样的，只不过把手机号换成了邮箱。</p>
<p><em><strong>重点来了！</strong></em>当学生被告知可以查询自己的面试结果时，必然有很多人同时想知道自己过了没，那么这一瞬间会有很多(bushi)(估计也就百来个)的请求打到数据库去，那这一瞬间对于数据库就会造成很大的压力。</p>
<p>虽然并发量是可以预估的，不会有多大，但是肯定会导致响应结果变慢。而这点并发量都会出问题，那如果请求是千万级的，甚至上亿的呢。</p>
<p>数据库的压力是可想而知的。</p>
<p>那么这里是怎么解决的呢？</p>
<p>那就是~<em><strong>缓存</strong></em>啦</p>
<p>这里我有做缓存，还记得main.go里的缓存初始化嘛？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存初始化</span></span><br><span class="line">kcommon.InitKcache()</span><br></pre></td></tr></table></figure>

<p><em><strong>当数据被请求时，首先会去查询缓存里是否有这个数据，如果有的话，直接把拿到的数据返回给查询者，根本不用走数据库。</strong></em></p>
<p>也就是说，在小于500的并发量情况下，每一个人都访问一次自己的面试状态后，缓存里还没装满，以后再查询的时候，全部走缓存，数据库就可以歇着了。</p>
<p>(数据库：笑死，根本没压力)</p>
<p>(缓存：？)</p>
<p>而这里设置的是，当数据在缓存里没击中时，才会去数据库里拿数据，然后把这条数据塞进缓存里。</p>
<p>也可以调整为，当报名后，就直接把数据放进缓存里，应对随时可能出现的请求~</p>
<h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p>管理员登录后，可以进行一系列的操作。</p>
<p>这里为了防止输入路由就直接可以进入管理员界面，做了JWT认证，当请求路由而不带认证的Token时，则不予放行。</p>
<h4 id="获取学生数据"><a href="#获取学生数据" class="headerlink" title="获取学生数据"></a>获取学生数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//获取请求中所请求的页数</span></span><br><span class="line">	pageStr := c.PostForm(<span class="string">&quot;pageNow&quot;</span>)</span><br><span class="line">	<span class="comment">//转换为整形</span></span><br><span class="line">	page,err := strconv.Atoi(pageStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kcommon.GlobalLog.Infof(err)</span><br><span class="line">		WriteResp(c,Message,GetDataErr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取数据库总页数</span></span><br><span class="line">	cnt := kservice.Count()</span><br><span class="line">	<span class="comment">//进行计算总共需要多少页展示 这里设置的一页展示十条数据(defCount) </span></span><br><span class="line">	<span class="keyword">if</span> cnt%defCount == <span class="number">0</span> &#123;</span><br><span class="line">		cnt /= defCount</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		cnt = cnt / defCount + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> page &gt; cnt &#123;</span><br><span class="line">		WriteResp(c,Message,PageErr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//按照分页获取数据</span></span><br><span class="line">	res,err := kservice.GetData(defCount,(page - <span class="number">1</span>) * defCount)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kcommon.GlobalLog.Infof(err)</span><br><span class="line">		WriteResp(c,Message,GetDataErr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusOK,gin.H&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span>:cnt,</span><br><span class="line">		<span class="string">&quot;res&quot;</span>:res,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/image-20210531101054576.png" alt="请求到的数据"></p>
<p>(PS：图中的数据是为了测试 自己写了循环生成的，没有实际意义。)</p>
<h4 id="改变面试状态"><a href="#改变面试状态" class="headerlink" title="改变面试状态"></a>改变面试状态</h4><p>当面试结束后，管理员需要去改变面试的状态，以便学生可以查到自己面试是否通过。</p>
<p>这个也没有什么好说的，在数据库更新字段而已。</p>
<p>需要注意的是，当数据库里的字段发生更新，缓存里也应该一起更新。</p>
<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>这里就是管理员需要做的一些操作，例如有人没有报名成功，或者填错信息，在这里去进行更改。</p>
<p>同样需要注意的是，在更新数据库时，要更新缓存里的数据。</p>
<p>而且，对缓存的更新应当在数据库的更新之前。关于缓存的这种设计思路，我就不细说了，网上有很多。</p>
<h4 id="打开-关闭-服务"><a href="#打开-关闭-服务" class="headerlink" title="打开/关闭 服务"></a>打开/关闭 服务</h4><p>网站对学生端暴露的服务应当是可以打开与关闭的。</p>
<p>在没有到预定的时间时，学生的报名或者查询应该是不可用使用的。</p>
<p>而到时间后，管理员开启服务，学生可以进行报名或者查询。</p>
<p>这里的实现也超级简单，就是设置一个bool型的全局变量，写一个中间件去访问这个变量就好，只有这个变量为true时，网站才会提供服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间控制服务是否开启的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServerOpen</span><span class="params">()</span> <span class="title">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">//如果控制服务开关的变量为false 则不予服务</span></span><br><span class="line">		<span class="keyword">if</span> !kcommon.ServerOpen &#123;</span><br><span class="line">			WriteResp(c,Message,kcommon.NotOpen)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//放行</span></span><br><span class="line">			c.Next()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="基于IP控制访问次数的中间件"><a href="#基于IP控制访问次数的中间件" class="headerlink" title="基于IP控制访问次数的中间件"></a>基于IP控制访问次数的中间件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IPLimit <span class="keyword">struct</span> &#123;</span><br><span class="line">	IP   <span class="keyword">string</span></span><br><span class="line">	time time.Time</span><br><span class="line">	nums <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上下文中获取到来访者的IP地址，然后把IP作为key放进一个新的缓存里。</p>
<p>如果缓存里没有这个ip，说明是第一次访问。那么将其加入缓存，时间为当前时间，nums置为0.</p>
<p>当它在缓存里时，说明这个ip已经访问过了，会将nums++，然后去做个判断。</p>
<p>当这个ip在一定的时间里访问次数达到一定数量时，将会被判定为恶意攻击，然后会被禁掉一定时间不能访问网站。</p>
<p>这个的实现是对结构体里的time进行一定的操作，而后面在访问到时就会被判断到，从而达到禁掉的效果。</p>
<h3 id="基于令牌桶控制访问次数的中间件"><a href="#基于令牌桶控制访问次数的中间件" class="headerlink" title="基于令牌桶控制访问次数的中间件"></a>基于令牌桶控制访问次数的中间件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimitMiddleware</span><span class="params">(fillInterval time.Duration, <span class="built_in">cap</span> <span class="keyword">int64</span>)</span> <span class="title">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   bucket := ratelimit.NewBucket(fillInterval, <span class="built_in">cap</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 如果取不到令牌就中断本次请求返回 rate limit...</span></span><br><span class="line">      <span class="keyword">if</span> bucket.TakeAvailable(<span class="number">1</span>) &lt; <span class="number">1</span> &#123;</span><br><span class="line">         c.JSON(http.StatusOK,gin.H&#123;</span><br><span class="line">            Message:TooManyVisiters ,</span><br><span class="line">         &#125;)</span><br><span class="line">         c.Abort()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.Next()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是参照网上的写法，也是用的第三方库。</p>
<p>实际上这个封装的就很简单，开箱即用。</p>
<p>令牌桶就是一个桶里生成一定数量的令牌，当桶里还有令牌时，那么来访者取走一个，可以访问网站。</p>
<p>如果桶里的令牌都被取走了，那么来访者就会被告知当前访问人数过多，请稍后再访问。</p>
<p>前面基于IP的中间件是防止个人进行恶意攻击而限流，而这个是根据总的访问量来限流。</p>
<p>比如，我设置了令牌桶的大小为60个，一秒钟补充5个，那么，当桶里的令牌都被取走后，一秒钟补充了5个，网站还可以为5个来访者进行服务。</p>
<p>桶的大小和补充速率的设定是很重要的事情。</p>
<p>设置大了，自己的服务器扛不住压力；小了，用户的体验将会大打折扣。</p>
<p>因此，在使用令牌桶时，需要仔细斟酌这两个数值的设置。</p>
<h3 id="基于JWT的身份认证"><a href="#基于JWT的身份认证" class="headerlink" title="基于JWT的身份认证"></a>基于JWT的身份认证</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTAuthMiddleware</span><span class="params">()</span> <span class="title">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      token := c.PostForm(<span class="string">&quot;Token&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> token == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">         WriteResp(c,Message,NotLogin)</span><br><span class="line">         c.Abort()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      _,err := kcommon.ParseToken(token)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         WriteResp(c,Message,JWTErr)</span><br><span class="line">         c.Abort()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.Next()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JWT是什么我就不多说了，想学习的小伙伴可以自己去搜，大把的资源。</p>
<p>当来访者请求未携带token，会被判断为未登录。</p>
<p>错误时，提示token错误，不能登录。</p>
<p>当token正确，才可以执行想要的功能。</p>
<p>放一段解析token的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ParseToken 解析JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="keyword">string</span>)</span> <span class="params">(*MyClaims, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 解析token</span></span><br><span class="line">   token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> MySecret, <span class="literal">nil</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="comment">// 校验token</span></span><br><span class="line">      <span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些就是这个项目里我认为还算有营养的点啦</p>
<p>毕竟这个项目确实很简单，没有太多值得细细说的。</p>
<p>其实说起来，写的也并不好，还有许多可以规范的点。</p>
<p>例如，model层的返回数据格式可以统一起来，然后加一个异步访问数据库的控制函数，可以更好的应对高并发的场景。</p>
<p>而一些const，都采用了string的返回值，但是在与前端大佬的沟通过后，觉得可以设定一些状态码用以返回。</p>
<p>而超时控制、结构划分、缓存、日志的使用这些，都还是可以细化优化的，不过也就不再搞了，准备开始写官网。</p>
<p>作为官网的一个模块，自己第一个项目的起步，也算还不错。</p>
<p>记录在这里，是对自己项目的一个总结反思，也是一种分享。</p>
<p>希望对看到这里的你有所帮助~</p>
<p>最后晒一下儿童节礼物(半价淘来就是舒服)</p>
<p><img src="/2021/05/29/Golang%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%BA%B3%E6%96%B0%E6%8A%A5%E5%90%8D%E7%BD%91%E7%AB%99/OS.jpg" alt="OS"></p>
]]></content>
      <categories>
        <category>golang</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>web</tag>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
